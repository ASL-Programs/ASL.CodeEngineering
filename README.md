# ASL.CodeEngineering

This repository contains the early skeleton of **ASL.CodeEngineering**, a polyglot
autonomous code engineering tool.

Run `dotnet build ASL.CodeEngineering.sln` to build all projects (requires the .NET SDK).

To launch the WPF application, run `dotnet run --project src/ASL.CodeEngineering.App`.
The UI uses WPF and therefore runs only on Windows systems.

## Building the WPF application

1. Open `ASL.CodeEngineering.sln` in **Visual Studio** and choose **Build > Publish** to produce a Release build.
2. Or run `dotnet publish src/ASL.CodeEngineering.App -c Release`.

The compiled `.exe` appears under `src/ASL.CodeEngineering.App/bin/Release/net7.0-windows/`.

## Testing

Unit tests are run with `dotnet test` from the repository root. You need a working .NET SDK, Python and Node.js installation. Because the test project targets `net7.0-windows`, tests must run on Windows. Individual tests skip automatically when required tools such as `dotnet`, `python` or `node` are missing.

Initial structure for the autonomous polyglot code engineering system.

## Repository structure

- `ai_providers/` – additional AI provider implementations or third‑party
  integrations.
- `plugins/` – extensions that add functionality to the core tool.
- `knowledge_base/` – persistent learning data gathered by the agent. Provider
  summaries from each run are also aggregated into `knowledge_base/meta/`. Benchmark insights are stored in `knowledge_base/meta/language_insights.json`.
- `knowledge_base/packages/` – curated guides loaded by the learning engine at startup.
- `knowledge_base/offline_training/` – sample datasets used to seed offline models.
- `data/` – runtime data generated by AI providers and the application. Older versions are archived under `data/versions/`.
- `logs/` – log files for debugging and audit. When `LOG_ENCRYPTION_KEY` is set
  the contents are AES encrypted.
- `code/` – workspace for generated or user‑provided code.
- `src/` – .NET source projects:
  - `ASL.CodeEngineering.App` – WPF application hosting the UI.
  - `ASL.CodeEngineering.AI` – library with the `IAIProvider` abstraction and
    sample providers (`EchoAIProvider`, `ReverseAIProvider`, `OpenAIProvider`, `LocalAIProvider`).
- `tests/` – unit tests for the provider library.
- `knowledge_base/plans/` – outputs from `ProjectPlanner` that map open roadmap
  tasks to modules, including a recommended language for each module.
- `.editorconfig` – formatting rules for C#, Markdown and other files. Visual
  Studio and `dotnet format` automatically apply these settings.

You can override the default locations of the `ai_providers` and `plugins`
directories by setting the `AI_PROVIDERS_DIR` or `PLUGINS_DIR` environment
variables. The application also respects the following variables for runtime
data and logs:

- `DATA_DIR` – base directory for chat logs and provider data (defaults to
  `data/` beside the executable).
- `KB_DIR` – directory for generated summaries and other knowledge base
  files (defaults to `knowledge_base/`).
- `LOGS_DIR` – directory for diagnostic logs (defaults to `logs/`). When this
  directory cannot be written to, logs fall back to a `logs/` folder located
  beside the executable.
- `LOG_ENCRYPTION_KEY` – optional key enabling AES-encrypted log files. When set,
  `SecureLogger` stores each log with a prepended IV so the audit trail remains
  confidential.
- `DISABLE_NETWORK_PROVIDERS` – set to `1` or `true` to remove providers that
  require internet access from the dropdown. Use this to enforce a fully offline
  workflow where all prompts stay inside the project directory.

## Extending AI providers

Providers must implement the `IAIProvider` interface defined in
`src/ASL.CodeEngineering.AI/IAIProvider.cs`.

1. Create a new **class library** project that references
   `ASL.CodeEngineering.AI` so your types can implement `IAIProvider`.
2. Build the library to produce a `.dll` file (any .NET language works).
3. Copy or move the resulting assembly into the `ai_providers/` directory
   located beside the application executable.

The application loads every provider assembly found in this folder automatically
at startup, so simply dropping a compiled DLL here makes it appear in the
provider list. You can override this search path by setting the
`AI_PROVIDERS_DIR` environment variable to point to a different directory.

If two providers share the same `Name` value, the duplicate is ignored and a warning
is logged at startup.

The example `OpenAIProvider` reads its API key from the `OPENAI_API_KEY` environment
variable or a local `openai_api_key.txt` file. It also respects an optional
`OPENAI_API_URL` variable to target a custom endpoint; when this variable is
empty, the provider defaults to `https://api.openai.com/v1/chat/completions`.
When using the file approach, place `openai_api_key.txt` in the same directory as the built application (for example `src/ASL.CodeEngineering.App/bin/Debug/net7.0-windows/`).
The repository `.gitignore` already excludes this file so you do not accidentally commit your secret key.

## Extending plugins

Analyzer and code runner plugins work just like AI providers. Implement
`IAnalyzerPlugin` or `ICodeRunnerPlugin` in a class library that references
`ASL.CodeEngineering.AI`, build the assembly and drop the resulting DLL into
the `plugins/` directory next to the application executable. The application
automatically loads all plugins found in this folder at startup. Set the
`PLUGINS_DIR` environment variable if your plugins are located in a custom
directory. If a plugin uses the same name as a built-in component or another plugin,
the duplicate is ignored and a warning is logged.

Loaded plugins and providers are listed under the **Plugins** tab of the main window.
Each entry shows its version string with a checkbox to enable or disable the plugin
for the current session.
## Generating interop wrappers

Use `InteropGenerator` to scaffold small cross-language projects. To create a .NET wrapper that executes a Python script:

```csharp
string path = InteropGenerator.CreatePythonWrapper("MyWrapper", outputDir);
```

The method creates `outputDir/MyWrapper/` with `MyWrapper.csproj`, `Program.cs` and `script.py`. Build it using `dotnet build` or the `DotnetBuildTestRunner`.

To create a wrapper that executes a Node.js script:

```csharp
string path = InteropGenerator.CreateNodeWrapper("MyWrapper", outputDir);
```

This produces `outputDir/MyWrapper/` with `MyWrapper.csproj`, `Program.cs` and `script.js`. Build it with `dotnet build` or the `DotnetBuildTestRunner`.

## Generating new projects

Use `ProjectGenerator.GenerateAsync` to scaffold a basic project. Provide a description, the target language and an output directory:

```csharp
string path = await ProjectGenerator.GenerateAsync("My App", "C#", projectsDir);
```

When triggered from the UI's **New Project** mode, projects are stored under `projects/` and generation can be stopped with the **Stop** button.


## Analyzing feature requests

Use `FeatureLanguageAnalyzer.Recommend` to choose a language for new features or plugins:

```csharp
string lang = FeatureLanguageAnalyzer.Recommend("Add statistical charts");
```

Run `BenchmarkHarness.RunAsync()` to gather build timings for supported languages. Results are stored in `knowledge_base/benchmarks/benchmarks.jsonl`.

## Knowledge packages

The `knowledge_base/packages/` directory holds curated guides used by the
`AutonomousLearningEngine`. These include:

- `learn_to_learn` – strategies for rapidly acquiring new skills.
- `software_languages` – notes on using C# and the .NET ecosystem.
- `chat_interaction` – tips for effective conversations with AI.

When the application starts, a list of these packages appears below the
learning controls. Uncheck a package to disable it for the current session.
The contents of the enabled packages are appended to the self-improvement prompt
each time the learning engine runs.

## Offline learning

The `OfflineLearning` module provides lightweight tensor operations and a
gradient descent trainer. Models can be loaded from or saved to `.pt` or `.onnx`
files and versions are archived under `data/models/`. Passing an
`OfflineLearning.OfflineModel` instance to `AutonomousLearningEngine.RunAsync`
will update the model with harmonized data during each cycle.
On first run, `ModelLoader` looks for `knowledge_base/offline_training/data.csv`
to create an initial model if no saved weights exist.

## Previewing updates

Each build archives the `src/` directory under `data/versions/{timestamp}`.
Use the **Preview Update** button to launch the most recent archive in an
isolated process. If the preview looks correct, confirm the prompt to switch the
working `src/` directory via `VersionManager.RestoreLatest`.

## Documentation automation

A `DocsUpdater` module watches learning cycles. Each time a cycle completes it copies `AGENTS.md` and `NEXT_STEPS.md` to `docs/archive/` with a timestamp and marks completed tasks `[x]`. It also appends a note to `AGENTS.md` for auditing.
`AutonomousLearningEngine` calls this updater after each iteration so documentation stays in sync during automated runs.

### Analytics dashboard

`ProjectPlanner.GeneratePlans` recommends a language for each module based on open tasks.
The **Dashboard** window displays these recommendations together with crawl summaries and
benchmark insights produced by `MetaAnalyzer`.



## Choosing an AI provider

When the application starts, a dropdown appears at the top of the main window
listing all available providers. Select a provider (for example **Echo**,
**Reverse**, **Local**, or **OpenAI**) before sending a prompt. The selection determines
which `IAIProvider` implementation handles your chat messages. If
`DISABLE_NETWORK_PROVIDERS` is enabled, only local providers such as **Echo** and
**Reverse** are available.

### Security and privacy

Providers such as `OpenAIProvider` communicate with external services over the
internet. Prompts and responses are transmitted to those providers, so avoid
sending confidential or sensitive information. API keys can be stored locally in
`openai_api_key.txt` if you prefer not to set environment variables.
Enable `DISABLE_NETWORK_PROVIDERS` to force the application into an offline
mode where only local providers are available and all data remains within the
project directory.

## Roadmap

The project aims to become a self‑improving polyglot engineer capable of using
the best language or tool for each task. Future updates will integrate more AI
providers, support plugins for new languages, and add automated learning loops
to continuously refine its own code base.

## Workflow files

Several markdown files capture the project's rules and decisions. Make sure to
review and update them as part of your development process:

- `AGENTS.md` – overarching roadmap and guidelines. Mark items complete here.
- `NEXT_STEPS.md` – running log of planned actions. Keep this file current as
  tasks progress.
- `REFERENCE_FILES.md` – list of documents or configs worth revisiting. Add
  entries whenever new references are created.
- `LANGUAGE_DECISIONS.md` – explains why each programming language or tool is
  used. Update it after significant changes.

Always consult these files before you start work and amend them whenever your
contributions affect the workflow.

