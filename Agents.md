# TODO.md - ASL.CodeEngineering
### Autonomous Polyglot AI Software Engineer for Windows (.exe)

---

## Core Mission

> **ASL.CodeEngineering must be developed as a truly polyglot, self-improving autonomous software engineer for Windows:**
> - All components must be written in the best-suited programming language and technology for their function (C#, Python, C++, Java, R, JavaScript, Bash, etc.).
> - The application itself is a portable, local-first Windows executable (WPF-based .exe), with all data, logs, configs, models, and code stored ONLY in the project root directory.
> - The system continuously learns, self-upgrades, and applies autonomous improvements—both to itself and to any user-given project or roadmap (TODO.md).

---

## AI-Driven Polyglot Development Principles

- **No single language or technology restriction:**  
  - Each module, helper, or feature must be written in the most optimal language for its task.
  - All components must be automatically integrated, with glue code or wrappers as needed (interop: e.g., C#↔Python, C++ for performance, R for analytics, JS for visualization).
- **Codex (or any AI) must benchmark and meta-learn which tools/languages work best, refactor as needed, and always optimize for maintainability, efficiency, and performance.**
- **Result:** A truly polyglot, modular, and self-optimizing engineering system—never locked to a single stack.

---

## 0. Project Setup & Core Principles

- [ ] 0.1. Initialize a WPF project for ASL.CodeEngineering (.exe, portable, local-only)
- [ ] 0.2. Structure all data, logs, configs, plugins, and code under the project root (never use AppData or cloud)
- [ ] 0.3. Set up modular, extensible architecture (plugins/extensions for AI, analyzers, code runners, etc.)
- [ ] 0.4. Create initial folders: `/data`, `/logs`, `/plugins`, `/ai_providers`, `/knowledge_base`, `/code`
- [ ] 0.5. Maintain absolute data sovereignty: nothing leaves the project directory

---

## 1. Multi-AI & Local AI Integration

- [ ] 1.1. Integrate multiple AI providers: OpenAI, Claude, Gemini, and LocalAI (Llama, Ollama, GPT4All, etc.)
- [ ] 1.2. Use modular AIProvider abstraction for easy future integrations
- [ ] 1.3. Archive every AI's outputs, code, logs, chat, and learning under `/data/{aiName}/`
- [ ] 1.4. Maintain a unified meta-knowledge base for cross-AI comparison, benchmarking, and insights
- [ ] 1.5. All data, models, and learning are portable and stored locally

---

## 2. Hyper-Advanced Polyglot Code Editor & Build/Test

- [ ] 2.1. Integrate an advanced code editor (AvalonEdit or similar):
    - Support for multi-language syntax, snippets, navigation, and real-time linting
    - Project explorer: user can select or assign any folder as a project (MCP)
- [ ] 2.2. For every module or feature, **AI must select and implement the best language/technology** (C#, Python, C++, Java, R, JS, Bash, etc.)
- [ ] 2.3. Implement automated build/test runners for each supported language (dotnet, pip/pytest, gcc/clang, javac, Rscript, npm, etc.)
- [ ] 2.4. Automatically generate and manage glue code/wrappers for interop (e.g., Python↔C#, C++↔.NET, etc.)
- [ ] 2.5. Benchmark, compare, and meta-learn which languages/tools deliver the best results for each use-case

---

## 3. Dual-Mode Learning & Self-Improvement

- [ ] 3.1. **Full Autonomous Learning Mode**
    - On “Start Learning”, the agent continuously explores, learns, and self-upgrades using online sources, AI chats, open-source mining, and self-analysis
    - Seeks to produce and propose better versions of itself—algorithms, workflows, refactorings, and documentation
- [ ] 3.2. **Task-Focused Conditional Learning Mode**
    - On “Pause” (or when autonomous learning is disabled), focus solely on user-assigned tasks (e.g., provided TODO.md, code review, project improvements)
    - While working, all actions (build, test, fix, optimize) are logged as new learning episodes
    - **If a problem/error cannot be solved using the local knowledge base, the system automatically resumes online research and AI queries—once solved, returns to focused task mode**
    - Both learning layers (autonomous, task-focused) are logged and analyzed for future improvement

---

## 4. Autonomous Project Engineering & Refactoring

- [ ] 4.1. Ingest and understand any roadmap (TODO.md), project folder, or legacy codebase (multi-language OK)
- [ ] 4.2. Auto-plan project execution: break down tasks, select optimal language/tech per task, schedule build/test/integration
- [ ] 4.3. For each module:
    - Generate code in the best-suited language
    - Integrate modules, generate required glue code
    - Auto-build/test, self-fix errors/warnings, repeat until successful
- [ ] 4.4. For existing projects: analyze code, find bugs/smells/anti-patterns, propose or auto-apply improvements/refactors (multi-language OK)
- [ ] 4.5. Every change, fix, or upgrade is versioned and user-reviewable

---

## 5. Automated Knowledge Mining & Reporting

- [ ] 5.1. Crawl open source, docs, StackOverflow, HN, Reddit, arxiv, etc. for all supported languages/technologies
- [ ] 5.2. Continuously update both per-AI and unified knowledge bases
- [ ] 5.3. Generate self-documenting code (docstrings/XMLDocs/Markdown), project milestone reports, and meta-learning summaries
- [ ] 5.4. Visual dashboard: learning progress, knowledge graphs, AI/language/tool comparisons, and improvement trends

---

## 6. User Interaction & Control

- [ ] 6.1. User can select/assign any folder as the project root (MCP), provide TODO.md or custom tasks
- [ ] 6.2. Show all learning, progress, and self-upgrade suggestions; user can accept/rollback any changes
- [ ] 6.3. Option to pause/resume autonomous learning at any time
- [ ] 6.4. All code, data, and models stay local in the project directory

---

## 7. Continuous Self-Upgrade & Meta-Learning

- [ ] 7.1. At every learning cycle, the system must seek to create and propose an improved version of itself—algorithms, code, workflows, knowledge structures, and tools
- [ ] 7.2. Archive all previous versions/experiments for user review/comparison
- [ ] 7.3. Meta-analyze which languages, tools, AIs, or strategies produce the best results, and update future learning accordingly

---

## Short Mission Statement

> ASL.CodeEngineering is an autonomous, self-upgrading, polyglot AI code engineer:  
> - It develops and improves both itself and any project you give it, using the best tools, languages, and strategies—without limitations.
> - All work is fully local, portable, and privacy-first as a Windows .exe.
> - **Every function, module, and helper must be written in the optimal language and technology for its purpose—no language boundaries.**
